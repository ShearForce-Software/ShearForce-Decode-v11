= Shear Force Software Team To-Do List:

== Tasks to be worked


=== Akshay

- [ ] MEASURE shooter optimum RPMs over distances with new shooter structure at different ramp positions
- [ ] AUTO-OBELISK: Add "detectObeliskMotif()" to every existing Auto routine
- [ ] AUTO-OBELISK: Create a NEW blue-far that goes to the correct line based on the obelisk motif instead of always going to the second line

=== Gianna

- [ ] MEASURE shooter optimum RPMs over distances with new shooter structure at different ramp positions
- [ ] Test lowering the RunAutoLifter() sensor distance (currently at 1.5 inches, probably needs to be smaller, like 3/4 or 1.0)
- [ ] Separate the resetTurretAndPosition() from the resetYaw logic.
  1. Connect theRobot.resetPositionToZero to (gamepad1.dpadUp + options),
  2. Connect theRobot.resetTurret to (gamepad2.square + options)
  2. Make the resetTurretAndPosition() harder to accidentally do (gamepad1.triangle + share)
  3. Make triangle only back to just doing a resetYaw
- [ ] Make manual turret controls work with gamepad2.right_stickX (so easier to manually fix turret)
  * Can leave existing controls in place too, make it an OR condition
- [ ] INTAKE-1: Add auto intake logic to second thread in redFarAuto, comment out other intake commands, TEST
  * be sure to put inside a check that run has been started (don't want auto intake running during init)
- [ ] INTAKE-2: if redFarAuto changes work, then implement and test on the other auto routines

=== Shrey

- [ ] MEASURE shooter optimum RPMs over distances with new shooter structure at different ramp positions
- Tune built-in PIDF using dashboard to achieve faster recovery without overshoots
  * Run Manual - put notes in comments of SetShooterPIDFCoefficients()
    ** [x] RECORD velocity and power values for small triangle position
    ** [ ] RECORD velocity and power values for AUTO Close position
    ** [x] RECORD current PIDF values from telemetry
  * Run Manual with DASHBOARD connected from small triangle position
    ** [ ] In Dashboard, change **shooterPIDF_Enabled** to be true
    ** [ ] Change **shooterF** to be 80% of velocity value for small triangle shot above
    ** [ ] Increase **shooterP** slowly until motor velocity starts to oscillate around target velocity
    ** [ ] Increase **shooterD** slowly to eliminate overshoot and minimize oscillations
    ** [ ] If velocity staying under target velocity, slowly increase **shooterI** until gets to target without significantly overshooting
    ** [ ] Tweak the 3 values until happy with shot recovery and spin up at small triangle location
    ** [ ] RECORD the 4 values in comments in SetShooterPIDFCoefficients(), change the defaults to match
  * [ ] Repeat the dashboard tuning process at the close up shooting position, determine if there is should be a second set of coefficients stored that could be swapped back and forth, or if the small triangle ones are sufficient for close up too
  * [ ] if PIDF seems effective, turn on for auto and remove the spin up while loops and RETEST

- [ ] AUTO: Experiment with lowering sleep time for lifterUp, should be able to do 250 milliseconds
- [ ] AUTO: Test, test, test -- need all 3 balls to shoot consistently every time, and all balls to be ingested
- [ ] AUTO: Experiment with lowering sleep time for lifterDown

=== Tong

- [ ] SHOOTER: Develop new optimum RPM calculator using new data, probably need optimum ramp calculator too
- [x] Add servo controls for new launch ramp
1. Add servo to HW Init calls
2. Create SetPosition routine for the launchRampServo
3. Add telemetry to show the current commanded position
4. Add manual controls (gamepad2.leftStickY -- note this analog not push-button, needs a dead zone)
5. Create auto boolean mode flag in HW class (default to true, with manual overriding)
6. Add manual method to change auto mode (gamepad2.dpadDown + Share)
- [ ] AUTO: develop and test an auto to get the 3 balls on the wall
- [ ] AUTO: develop and test an auto to shoot 3 balls, pick up 3 on wall and shoot them, pick up correct line, release the gate, then shoot 3 balls

== Next Level Stuff

- [ ] Integrate logic to use the ball distance detection sensor to detect the loaded ball color and change an indicator light to that color
- [ ] Develop lots of autonomous options and test them
- [ ] AUTO: Implement Blue small triangle start that can shoot 6 balls, and pick up correct line and shoot them then park for any of the 3 choices
- [ ] AUTO: Implement Red small triangle start that can shoot 6 balls, and pick up correct line and shoot them then park for any of the 3 choices




