= Shear Force Software Team To-Do List:

== Tasks to be worked


=== Akshay

- [x] AUTO: Test: Change Close Autos to initialize shooter motor to correct speed instead of max like it is currently doing
- [ ] AUTO: Read the obelisk and set a variable for what pattern is being shown
- [ ] AUTO: Limit when intake motor is on to only when needed for the close autos

=== Gianna

- [ ] INTAKE: Integrate logic to use the ball break beam sensors to turn intake on/off automatically
* if (inside sensor says empty && outside sensor ball present) then turn intake on
* else if (inside sensor says ball present) then turn intake off
* Example code for sensor is at:
** FtcRobotController -> external.samples -> SensorDigitalTouch
- [ ] Test all buttons, make them all work, in particular it appears a lot of the SHARE + buttons are not working correctly
- [ ] Separate the resetTurretAndPosition() from the resetYaw logic.  Make 2 separate buttons, 1 to reset position (gamepad1), and 1 to reset turret (gamepad2), so can do only what we need and only have to drive to 0,0 when position is off
- [ ] Add servo controls for new launch ramp

=== Shrey

- Tune built-in PIDF using dashboard to achieve faster recovery without overshoots
  * Run Manual - put notes in comments of SetShooterPIDFCoefficients()
    ** [x] RECORD velocity and power values for small triangle position
    ** [ ] RECORD velocity and power values for AUTO Close position
    ** [x] RECORD current PIDF values from telemetry
  * Run Manual with DASHBOARD connected from small triangle position
    ** [ ] In Dashboard, change **shooterPIDF_Enabled** to be true
    ** [ ] Change **shooterF** to be 80% of velocity value for small triangle shot above
    ** [ ] Increase **shooterP** slowly until motor velocity starts to oscillate around target velocity
    ** [ ] Increase **shooterD** slowly to eliminate overshoot and minimize oscillations
    ** [ ] If velocity staying under target velocity, slowly increase **shooterI** until gets to target without significantly overshooting
    ** [ ] Tweak the 3 values until happy with shot recovery and spin up at small triangle location
    ** [ ] RECORD the 4 values in comments in SetShooterPIDFCoefficients(), change the defaults to match
  * [ ] Repeat the dashboard tuning process at the close up shooting position, determine if there is should be a second set of coefficients stored that could be swapped back and forth, or if the small triangle ones are sufficient for close up too
  * [ ] if PIDF seems effective, turn on for auto and remove the spin up while loops and RETEST

- [ ] AUTO: Experiment with lowering sleep time for lifterUp, should be able to do 250 milliseconds
- [ ] AUTO: Test, test, test -- need all 3 balls to shoot consistently every time, and all balls to be ingested
- [ ] AUTO: Experiment with lowering sleep time for lifterDown

=== Tong

- [x] Change Target positions to be back corner of goal instead of front center
- [x] Test the roadrunner distance calculator by changing SetUseOnlyWebcamForDistance(false) in manual control
  * probably want to subtract the distance from -60,-60 to -56,-56 in calculation, since that is the measurements based on
- [ ] Test the ability to update the roadrunner position based on the apriltag by setting SetUpdateRoadrunnerFromWebcamEnabled(true) in manual control
  * use telemetry of roadrunner position to check
  * physically pick up the robot and move it to force an update
- [x] Update CalculateOptimumShooterRPM() to use dynamic range logic using a % of distance between measurements, rather than flat step functions
  ** Example:
```
   double distanceAboveLower = 0.0;
   double rpmDifferenceInRange = 0.0;
   double differenceInMeasurements = 6.0; // inches
   if (distanceInInches >= 100) { optimumShooterRPM = 3500; }
   else if (distanceInInches >= 78) { optimumShooterRPM = 2950; }
   else if (distanceInInches >= 72) {
      distanceAboveLower = distanceInInches - 72;
      rpmDifferenceInRange = 2950 - 2800;
      optimumShooterRPM = 2800 + (distanceAboveLower / differenceInMeasurements) * rpmDifferenceInRange;
   }
   else if (distanceInInches >= 66) {
      distanceAboveLower = distanceInInches - 66;
      rpmDifferenceInRange = 2800 - 2750;
      optimumShooterRPM = 2750 + (distanceAboveLower / differenceInMeasurements) * rpmDifferenceInRange;
   }
   etc...

```
- [ ] AUTO: develop and test an auto to get the 3 balls on the wall
- [ ] Test shooter optimum RPMs over distances with new shooter structure
- [ ] AUTO: develop and test an auto to shoot 3 balls, pick up 3 on wall and shoot them, pick up correct line, release the gate, then shoot 3 balls

== Next Level Stuff

- [ ] Integrate logic to use the ball distance detection sensor to detect the loaded ball color and change an indicator light to that color
- [ ] Integrate April tag detection to the Autonomous routes, change intake order based on detected april tag
- [ ] Develop lots of autonomous options and test them
- [ ] AUTO: Implement Blue small triangle start that can shoot 6 balls, and pick up correct line and shoot them then park for any of the 3 choices
- [ ] AUTO: Implement Red small triangle start that can shoot 6 balls, and pick up correct line and shoot them then park for any of the 3 choices


== Advanced Shooter System Tasks

- [ ] Develop function to calculate the optimum launcher ramp height


